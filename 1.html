<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>md | 本五前端的铸剑阁</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/newblog/Aatrox.jpeg">
    <meta name="description" content="想成为无情的搬运工，但又想搞点原创，主要以笔记、心得为主吧">
    
    <link rel="preload" href="/newblog/assets/css/0.styles.156ef19a.css" as="style"><link rel="preload" href="/newblog/assets/js/app.dfcbd65b.js" as="script"><link rel="preload" href="/newblog/assets/js/2.6c36ac49.js" as="script"><link rel="preload" href="/newblog/assets/js/8.aec26ff0.js" as="script"><link rel="prefetch" href="/newblog/assets/js/10.cee57e82.js"><link rel="prefetch" href="/newblog/assets/js/11.9d968da0.js"><link rel="prefetch" href="/newblog/assets/js/12.9f16bb33.js"><link rel="prefetch" href="/newblog/assets/js/13.9cbedc21.js"><link rel="prefetch" href="/newblog/assets/js/14.2b2a091e.js"><link rel="prefetch" href="/newblog/assets/js/15.d574bfa3.js"><link rel="prefetch" href="/newblog/assets/js/16.c8f23644.js"><link rel="prefetch" href="/newblog/assets/js/17.3c2dc646.js"><link rel="prefetch" href="/newblog/assets/js/18.77d2c850.js"><link rel="prefetch" href="/newblog/assets/js/19.fa037ca0.js"><link rel="prefetch" href="/newblog/assets/js/20.8f22dcc7.js"><link rel="prefetch" href="/newblog/assets/js/21.a514ea92.js"><link rel="prefetch" href="/newblog/assets/js/22.ffcc7c1f.js"><link rel="prefetch" href="/newblog/assets/js/23.996fa639.js"><link rel="prefetch" href="/newblog/assets/js/24.8b95cc09.js"><link rel="prefetch" href="/newblog/assets/js/25.ff980aac.js"><link rel="prefetch" href="/newblog/assets/js/26.6c022870.js"><link rel="prefetch" href="/newblog/assets/js/27.8f066c47.js"><link rel="prefetch" href="/newblog/assets/js/28.cfe2df0d.js"><link rel="prefetch" href="/newblog/assets/js/29.89230ff6.js"><link rel="prefetch" href="/newblog/assets/js/3.d26b7c04.js"><link rel="prefetch" href="/newblog/assets/js/30.d6eaf50b.js"><link rel="prefetch" href="/newblog/assets/js/31.e3762850.js"><link rel="prefetch" href="/newblog/assets/js/4.b472bcd2.js"><link rel="prefetch" href="/newblog/assets/js/5.71765c1c.js"><link rel="prefetch" href="/newblog/assets/js/6.44aa996d.js"><link rel="prefetch" href="/newblog/assets/js/7.e09db61d.js"><link rel="prefetch" href="/newblog/assets/js/9.3ec6f23f.js">
    <link rel="stylesheet" href="/newblog/assets/css/0.styles.156ef19a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/newblog/" class="home-link router-link-active"><!----> <span class="site-name">本五前端的铸剑阁</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/newblog/plan/" class="nav-link">
  学习计划
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/newblog/plan/" class="nav-link">
  学习计划
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/newblog/" class="sidebar-heading clickable router-link-active open"><span>首页</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/newblog/plan.html" class="sidebar-link">学习计划</a></li><li><section class="sidebar-group is-sub-group depth-1"><a href="/newblog/fcc/main" class="sidebar-heading clickable"><span>fcc算法题解</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/newblog/fcc/intermediate.html" class="sidebar-link">算法中级</a></li><li><a href="/newblog/fcc/palindrome.html" class="sidebar-link">项目实战：回文检查器</a></li><li><a href="/newblog/fcc/convertToRoman.html" class="sidebar-link">项目实战：罗马数字转换器</a></li><li><a href="/newblog/fcc/rot13.html" class="sidebar-link">项目实战：凯撒密码</a></li><li><a href="/newblog/fcc/telephoneCheck.html" class="sidebar-link">项目实战：电话号码验证器</a></li><li><a href="/newblog/fcc/checkCashRegister.html" class="sidebar-link">项目实战：收银机</a></li></ul></section></li><li><a href="/newblog/leetcode/main.html" class="sidebar-link">leetcode题解</a></li><li><a href="/newblog/chrome/main.html" class="sidebar-link">浏览器相关</a></li><li><a href="/newblog/ready.html" class="sidebar-link">面试准备</a></li><li><a href="/newblog/git/main.html" class="sidebar-link">GIT</a></li><li><a href="/newblog/favorites.html" class="sidebar-link">收藏夹</a></li><li><a href="/newblog/chickenwater/main.html" class="sidebar-link">振奋人心的鸡汤</a></li><li><a href="/newblog/life.html" class="sidebar-link">生活打卡</a></li><li><a href="/newblog/newlife.html" class="sidebar-link">1月日报</a></li><li><a href="/newblog/weight.html" class="sidebar-link">减肥日志</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="md"><a href="#md" class="header-anchor">#</a> md</h1> <p>预计分享
1.cmd与es module
2.什么是esbuild
3.vue3 ts项目搭建
4.组内架构回顾
待做事项
1.填坑
7月份想填完的坑 前端架构师课程</p> <p>今天学习neirong</p> <h3 id="yargs"><a href="#yargs" class="header-anchor">#</a> yargs</h3> <ul><li>脚手架构成
<ul><li>bin：package.json中配置bin属性，npm link 本地安装</li> <li>command：命令</li> <li>options：参数（boolean/string/number）</li> <li>文件顶部增加 <code>#!/usr/bin/env node</code></li></ul></li> <li>脚手架初始化流程
<ul><li>构造函数：Yargs()</li> <li>常用方法：
<ul><li>Yargs.options</li> <li>Yargs.option</li> <li>Yargs.group</li> <li>Yargs.demandCommand</li> <li>Yargs.recommendCommands</li> <li>Yargs.strict</li> <li>Yargs.fail</li> <li>Yargs.alias</li> <li>Yargs.wrap</li> <li>Yargs.epilogue</li></ul></li></ul></li> <li>脚手架参数解析方法
<ul><li>hideBin(process.argv) / Yargs.argv</li> <li>Yargs.parse(argv, options)</li></ul></li> <li>命令注册方法
<ul><li>Yargs.command(command, describe, builder, handler)</li> <li>Yargs.command({ command, describe, builder, handler })</li></ul></li></ul> <h3 id="lerna"><a href="#lerna" class="header-anchor">#</a> Lerna</h3> <ul><li>Lerna 是基于 git+npm 的多package项目管理工具</li> <li>实现原理
<ul><li>通过 import-local 优先调用本地 lerna 命令</li> <li>通过 Yargs 生成脚手架，先注册全局属性，再注册命令，最后通过 parse 方法解析参数</li> <li>lerna 命令注册时需要传入 builder 和 handler 两个方法，builder 方法用于注册命令专属的 options，handler 用来处理命令的业务逻辑</li> <li>lerna 通过配置 npm 本地依赖的方式来进行本地开发，具体写法是在 package.json 的依赖中写入：<code>file:your-local-module-path</code> ，在 lerna publish 时会自动将该路径替换</li></ul></li></ul> <h3 id="node-js-模块路径解析流程"><a href="#node-js-模块路径解析流程" class="header-anchor">#</a> Node.js 模块路径解析流程</h3> <ul><li><p>Node.js 项目模块路径解析是通过 <code>require.resolve</code> 方法来实现的</p></li> <li><p><code>require.resolve</code> 就是通过 <code>Module._resolveFileName</code> 方法实现的</p></li> <li><div class="language- line-numbers-mode"><pre class="language-text"><code>require.resolve
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>实现原理：</p> <ul><li><div class="language- line-numbers-mode"><pre class="language-text"><code>Module._resolveFileName
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>方法核心流程有 3 点：</p> <ul><li>判断是否为内置模块</li> <li>通过 <code>Module._resolveLookupPaths</code> 方法生成 node_modules 可能存在的路径</li> <li>通过 <code>Module._findPath</code> 查询模块的真实路径</li></ul></li> <li><div class="language- line-numbers-mode"><pre class="language-text"><code>Module._findPath
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>核心流程有 4 点：</p> <ul><li>查询缓存（将 request 和 paths 通过 <code>\x00</code> 合并成 cacheKey）</li> <li>遍历 paths，将 path 与 request 组成文件路径 basePath</li> <li>如果 basePath 存在则调用 <code>fs.realPathSync</code> 获取文件真实路径</li> <li>将文件真实路径缓存到 <code>Module._pathCache</code>（key 就是前面生成的 cacheKey）</li></ul></li> <li><div class="language- line-numbers-mode"><pre class="language-text"><code>fs.realPathSync
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>核心流程有 3 点：</p> <ul><li><p>查询缓存（缓存的 key 为 p，即 <code>Module._findPath</code> 中生成的文件路径）</p></li> <li><p>从左往右遍历路径字符串，查询到</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>/
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>时，拆分路径，判断该路径是否为软链接，如果是软链接则查询真实链接，并生成新路径 p，然后继续往后遍历，这里有 1 个细节需要特别注意：</p> <ul><li>遍历过程中生成的子路径 base 会缓存在 knownHard 和 cache 中，避免重复查询</li></ul></li> <li><p>遍历完成得到模块对应的真实路径，此时会将原始路径 original 作为 key，真实路径作为 value，保存到缓存中</p></li></ul></li></ul></li> <li><p><code>require.resolve.paths</code> 等价于 <code>Module._resolveLookupPaths</code>，该方法用于获取所有 node_modules 可能存在的路径</p></li> <li><div class="language- line-numbers-mode"><pre class="language-text"><code>require.resolve.paths
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>实现原理：</p> <ul><li>如果路径为 <code>/</code>（根目录），直接返回 <code>['/node_modules']</code></li> <li>否则，将路径字符串从后往前遍历，查询到 <code>/</code> 时，拆分路径，在后面加上 node_modules，并传入一个 paths 数组，直至查询不到 <code>/</code> 后返回 paths 数组</li></ul></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/newblog/assets/js/app.dfcbd65b.js" defer></script><script src="/newblog/assets/js/2.6c36ac49.js" defer></script><script src="/newblog/assets/js/8.aec26ff0.js" defer></script>
  </body>
</html>
