<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Git 的工作区域和流程 | 本五前端的铸剑阁</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/newblog/Aatrox.jpeg">
    <meta name="description" content="想成为无情的搬运工，但又想搞点原创，主要以笔记、心得为主吧">
    
    <link rel="preload" href="/newblog/assets/css/0.styles.156ef19a.css" as="style"><link rel="preload" href="/newblog/assets/js/app.dfcbd65b.js" as="script"><link rel="preload" href="/newblog/assets/js/2.6c36ac49.js" as="script"><link rel="preload" href="/newblog/assets/js/21.a514ea92.js" as="script"><link rel="prefetch" href="/newblog/assets/js/10.cee57e82.js"><link rel="prefetch" href="/newblog/assets/js/11.9d968da0.js"><link rel="prefetch" href="/newblog/assets/js/12.9f16bb33.js"><link rel="prefetch" href="/newblog/assets/js/13.9cbedc21.js"><link rel="prefetch" href="/newblog/assets/js/14.2b2a091e.js"><link rel="prefetch" href="/newblog/assets/js/15.d574bfa3.js"><link rel="prefetch" href="/newblog/assets/js/16.c8f23644.js"><link rel="prefetch" href="/newblog/assets/js/17.3c2dc646.js"><link rel="prefetch" href="/newblog/assets/js/18.77d2c850.js"><link rel="prefetch" href="/newblog/assets/js/19.fa037ca0.js"><link rel="prefetch" href="/newblog/assets/js/20.8f22dcc7.js"><link rel="prefetch" href="/newblog/assets/js/22.ffcc7c1f.js"><link rel="prefetch" href="/newblog/assets/js/23.996fa639.js"><link rel="prefetch" href="/newblog/assets/js/24.8b95cc09.js"><link rel="prefetch" href="/newblog/assets/js/25.ff980aac.js"><link rel="prefetch" href="/newblog/assets/js/26.6c022870.js"><link rel="prefetch" href="/newblog/assets/js/27.8f066c47.js"><link rel="prefetch" href="/newblog/assets/js/28.cfe2df0d.js"><link rel="prefetch" href="/newblog/assets/js/29.89230ff6.js"><link rel="prefetch" href="/newblog/assets/js/3.d26b7c04.js"><link rel="prefetch" href="/newblog/assets/js/30.d6eaf50b.js"><link rel="prefetch" href="/newblog/assets/js/31.e3762850.js"><link rel="prefetch" href="/newblog/assets/js/4.b472bcd2.js"><link rel="prefetch" href="/newblog/assets/js/5.71765c1c.js"><link rel="prefetch" href="/newblog/assets/js/6.44aa996d.js"><link rel="prefetch" href="/newblog/assets/js/7.e09db61d.js"><link rel="prefetch" href="/newblog/assets/js/8.aec26ff0.js"><link rel="prefetch" href="/newblog/assets/js/9.3ec6f23f.js">
    <link rel="stylesheet" href="/newblog/assets/css/0.styles.156ef19a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/newblog/" class="home-link router-link-active"><!----> <span class="site-name">本五前端的铸剑阁</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/newblog/plan/" class="nav-link">
  学习计划
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/newblog/plan/" class="nav-link">
  学习计划
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/newblog/" class="sidebar-heading clickable router-link-active open"><span>首页</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/newblog/plan.html" class="sidebar-link">学习计划</a></li><li><section class="sidebar-group is-sub-group depth-1"><a href="/newblog/fcc/main" class="sidebar-heading clickable"><span>fcc算法题解</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/newblog/fcc/intermediate.html" class="sidebar-link">算法中级</a></li><li><a href="/newblog/fcc/palindrome.html" class="sidebar-link">项目实战：回文检查器</a></li><li><a href="/newblog/fcc/convertToRoman.html" class="sidebar-link">项目实战：罗马数字转换器</a></li><li><a href="/newblog/fcc/rot13.html" class="sidebar-link">项目实战：凯撒密码</a></li><li><a href="/newblog/fcc/telephoneCheck.html" class="sidebar-link">项目实战：电话号码验证器</a></li><li><a href="/newblog/fcc/checkCashRegister.html" class="sidebar-link">项目实战：收银机</a></li></ul></section></li><li><a href="/newblog/leetcode/main.html" class="sidebar-link">leetcode题解</a></li><li><a href="/newblog/chrome/main.html" class="sidebar-link">浏览器相关</a></li><li><a href="/newblog/ready.html" class="sidebar-link">面试准备</a></li><li><a href="/newblog/git/main.html" aria-current="page" class="active sidebar-link">GIT</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/newblog/git/main.html#git-的工作区域和流程" class="sidebar-link">Git 的工作区域和流程</a></li><li class="sidebar-sub-header"><a href="/newblog/git/main.html#git-基本操作" class="sidebar-link">Git 基本操作</a></li><li class="sidebar-sub-header"><a href="/newblog/git/main.html#工作中使用-git-解决问题的场景" class="sidebar-link">工作中使用 Git 解决问题的场景</a></li></ul></li><li><a href="/newblog/favorites.html" class="sidebar-link">收藏夹</a></li><li><a href="/newblog/chickenwater/main.html" class="sidebar-link">振奋人心的鸡汤</a></li><li><a href="/newblog/life.html" class="sidebar-link">生活打卡</a></li><li><a href="/newblog/newlife.html" class="sidebar-link">1月日报</a></li><li><a href="/newblog/weight.html" class="sidebar-link">减肥日志</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="git-的工作区域和流程"><a href="#git-的工作区域和流程" class="header-anchor">#</a> Git 的工作区域和流程</h2> <p>要想弄懂 Git 是怎么对我们的代码进行管理的，那首当其冲的是了解 Git 的工作区域是如何构成的。因为，只有彻底弄懂了 Git 工作区域的构成，你才可以在适当的区域使用合适的命令。如下图所示，此图包含了 Git 的 4 个工作区和一些常见的操作。</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec7210655b4d4fc4afcd1466d9aa2343~tplv-k3u1fbpfcp-watermark.awebp" alt="git"></p> <p>Workspace：工作区，就是平时进行开发改动的地方，是当前看到最新的内容，在开发的过程也就是对工作区的操作</p> <p>Index：暂存区，当执行 <code>git add</code> 的命令后，工作区的文件就会被移入暂存区，暂存区标记了当前工作区中那些内容是被 Git 管理的，当完成某个需求或者功能后需要提交代码，第一步就是通过 <code>git add</code> 先提交到暂存区。</p> <p>Repository：本地仓库，位于自己的电脑上，通过 <code>git commit</code> 提交暂存区的内容，会进入本地仓库。</p> <p>Remote：远程仓库，用来托管代码的服务器，远程仓库的内容能够被分布在多个地点的处于协作关系的本地仓库修改，本地仓库修改完代码后通过 <code>git push</code> 命令同步代码到远程仓库。</p> <p>一般来说，Git 的工作流程分为以下几步</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token number">1</span>.在工作区开发，添加，修改文件。
<span class="token number">2</span>.将修改后的文件放入暂存区。
<span class="token number">3</span>.将暂存区域的文件提交到本地仓库。
<span class="token number">4</span>.将本地仓库的修改推送到远程仓库。
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="git-基本操作"><a href="#git-基本操作" class="header-anchor">#</a> Git 基本操作</h2> <h3 id="git-add"><a href="#git-add" class="header-anchor">#</a> git add</h3> <p>添加文件到暂存区</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 添加某个文件到暂存区，后面可以跟多个文件，以空格区分</span>
<span class="token function">git</span> <span class="token function">add</span> xxx
<span class="token comment"># 添加当前更改的所有文件到暂存区。</span>
<span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span>
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h4 id="git-commit"><a href="#git-commit" class="header-anchor">#</a> git commit</h4> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 提交暂存的更改，会新开编辑器进行编辑</span>
<span class="token function">git</span> commit
<span class="token comment"># 提交暂存的更改，并记录下备注</span>
<span class="token function">git</span> commit -m <span class="token string">&quot;you message&quot;</span>
<span class="token comment"># 等同于 git add . &amp;&amp; git commit -m</span>
<span class="token function">git</span> commit -am
<span class="token comment"># 对最近一次的提交的信息进行修改,此操作会修改commit的hash值</span>
<span class="token function">git</span> commit --amend
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="git-pull"><a href="#git-pull" class="header-anchor">#</a> git pull</h3> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 从远程仓库拉取代码并合并到本地，可简写为 git pull 等同于 git fetch &amp;&amp; git merge</span>
<span class="token function">git</span> pull <span class="token operator">&lt;</span>远程主机名<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>远程分支名<span class="token operator">&gt;</span>:<span class="token operator">&lt;</span>本地分支名<span class="token operator">&gt;</span>
<span class="token comment"># 使用rebase的模式进行合并</span>
<span class="token function">git</span> pull --rebase <span class="token operator">&lt;</span>远程主机名<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>远程分支名<span class="token operator">&gt;</span>:<span class="token operator">&lt;</span>本地分支名<span class="token operator">&gt;</span>
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="git-fetch"><a href="#git-fetch" class="header-anchor">#</a> git fetch</h3> <p>与 <code>git pull</code> 不同的是 <code>git fetch</code> 操作仅仅只会拉取远程的更改，不会自动进行 merge 操作。对你当前的代码没有影响</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 获取远程仓库特定分支的更新</span>
<span class="token function">git</span> fetch <span class="token operator">&lt;</span>远程主机名<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>分支名<span class="token operator">&gt;</span>
<span class="token comment"># 获取远程仓库所有分支的更新</span>
<span class="token function">git</span> fetch --all
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="git-branch"><a href="#git-branch" class="header-anchor">#</a> git branch</h3> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 新建本地分支，但不切换</span>
<span class="token function">git</span> branch <span class="token operator">&lt;</span>branch-name<span class="token operator">&gt;</span>
<span class="token comment"># 查看本地分支</span>
<span class="token function">git</span> branch
<span class="token comment"># 查看远程分支</span>
<span class="token function">git</span> branch -r
<span class="token comment"># 查看本地和远程分支</span>
<span class="token function">git</span> branch -a
<span class="token comment"># 删除本地分支</span>
<span class="token function">git</span> branch -D <span class="token operator">&lt;</span>branch-nane<span class="token operator">&gt;</span>
<span class="token comment"># 重新命名分支</span>
<span class="token function">git</span> branch -m <span class="token operator">&lt;</span>old-branch-name<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>new-branch-name<span class="token operator">&gt;</span>
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h2 id="工作中使用-git-解决问题的场景"><a href="#工作中使用-git-解决问题的场景" class="header-anchor">#</a> 工作中使用 Git 解决问题的场景</h2> <h3 id="git-rebase-让你的提交记录更加清晰可读"><a href="#git-rebase-让你的提交记录更加清晰可读" class="header-anchor">#</a> git rebase 让你的提交记录更加清晰可读</h3> <h4 id="git-rebase-的使用"><a href="#git-rebase-的使用" class="header-anchor">#</a> git rebase 的使用</h4> <p>rebase 翻译为变基，他的作用和 merge 很相似，用于把一个分支的修改合并到当前分支上。</p> <p>如下图所示，下图介绍了经过 rebase 后提交历史的变化情况。</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b169721a6bfc42a7b4754f7c5d65672d~tplv-k3u1fbpfcp-watermark.awebp" alt="WechatIMG2.png"></p> <p>现在我们来用一个例子来解释一下上面的过程。</p> <p>假设我们现在有 2 条分支，一个为 master，一个为 feature/1，他们都基于初始的一个提交 add readme 进行检出分支，之后，master 分支增加了 3.js 和 4.js 的文件，分别进行了 2 次提交，feature/1 也增加了 1.js 和 2.js 的文件，分别对应以下 2 条提交记录。</p> <p>此时，对应分支的提交记录如下。</p> <p>master 分支如下图：</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64147d864ec44c3494560c3547010bbe~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20210531144909187.png"></p> <p>feature/1 分支如下图</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81543f378abd4a16bf74947d2200ffa9~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20210531145504071.png"></p> <p>结合起来看是这样的</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35519191523f4568bf6135bfcfb223a2~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20210531145553107.png"></p> <p>此时，切换到 feature/1 分支下，执行 <code>git rebase master</code>，成功之后，通过 <code>git log</code> 查看记录。</p> <p>如下图所示：可以看到先是逐个应用了 mater 分支的更改，然后以 master 分支最后的提交作为基点，再逐个应用 feature/1 的每个更改。</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fcb57edd0b594ff6ad7bc7d25ba128f9~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20210531150719965.png"></p> <p>所以，我们的提交记录就会非常清晰，没有分叉，上面演示的是比较顺利的情况，但是大部分情况下，rebase 的过程中会产生冲突的，此时，就需要手动解决冲突，然后使用依次 <code>git add</code> 、<code>git rebase --continue</code> 的方式来处理冲突，完成 rebase 的过程，如果不想要某次 rebase 的结果，那么需要使用 <code>git rebase --skip</code> 来跳过这次 rebase 操作。</p> <h4 id="git-merge-和-git-rebase-的区别"><a href="#git-merge-和-git-rebase-的区别" class="header-anchor">#</a> git merge 和 git rebase 的区别</h4> <p>不同于 <code>git rebase</code> 的是，<code>git merge</code> 在不是 fast-forward（快速合并）的情况下，会产生一条额外的合并记录，类似 <code>Merge branch 'xxx' into 'xxx'</code> 的一条提交信息。</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14b182abe7c54161959596eb5b140299~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20210531151838328.png"></p> <p>另外，在解决冲突的时候，用 merge 只需要解决一次冲突即可，简单粗暴，而用 rebase 的时候 ，需要依次解决每次的冲突，才可以提交。</p> <h4 id="git-rebase-交互模式"><a href="#git-rebase-交互模式" class="header-anchor">#</a> git rebase 交互模式</h4> <p>在开发中，常会遇到在一个分支上产生了很多的无效的提交，这种情况下使用 rebase 的交互式模式可以把已经发生的多次提交压缩成一次提交，得到了一个干净的提交历史，例如某个分支的提交历史情况如下：</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee27b108f03443a58c19600cac7ddf70~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20210518211345258.png"></p> <p>进入交互式模式的方式是执行：</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code><span class="token function">git</span> rebase -i <span class="token operator">&lt;</span>base-commit<span class="token operator">&gt;</span>
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>参数 <code>base-commit</code> 就是指明操作的基点提交对象，基于这个基点进行 rebase 的操作，对于上述提交历史的例子，我们要把最后的一个提交对象（ ac18084 ）之前的提交压缩成一次提交，我们需要执行的命令格式是：</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code><span class="token function">git</span> rebase -i ac18084
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>此时会进入一个 vim 的交互式页面，编辑器列出的信息像下列这样。</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3fd2ea54dbbe4c88a51fc652c6b1e86f~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20210518212036198.png"></p> <p>想要合并这一堆更改，我们要使用 Squash 策略进行合并，即把当前的 commit 和它的上一个 commit 内容进行合并， 大概可以表示为下面这样，在交互模式的 rebase 下，至少保留一个 pick，否则命令会执行失败。</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>pick  <span class="token punctuation">..</span>. <span class="token punctuation">..</span>.
s     <span class="token punctuation">..</span>. <span class="token punctuation">..</span>.
s     <span class="token punctuation">..</span>. <span class="token punctuation">..</span>.
s     <span class="token punctuation">..</span>. <span class="token punctuation">..</span>.
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>修改文件后 按下 <code>:</code> 然后 <code>wq</code> 保存退出，此时又会弹出一个编辑页面，这个页面是用来编辑提交的信息，修改为 <code>feat: 更正</code>，最后保存一下，接着使用 <code>git branch</code> 查看提交的 commit 信息，rebase 后的提交记录如下图所示，是不是清爽了很多？rebase 操作可以让我们的提交历史变得更加清晰。</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2586ec49060f4dfc9006c8f3fc532260~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20210518212812000.png"></p> <blockquote><p>特别注意，只能在自己使用的 feature 分支上进行 rebase 操作，不允许在集成分支上进行 rebase，因为这种操作会修改集成分支的历史记录。</p></blockquote> <h4 id="使用-git-cherry-pick-获取指定的-commit"><a href="#使用-git-cherry-pick-获取指定的-commit" class="header-anchor">#</a> 使用 git cherry-pick 获取指定的 commit</h4> <p><code>git cherry-pick</code> 可以理解为”挑拣”提交，和 merge 合并一个分支的所有提交不同的是，它会获取某一个分支的单笔提交，并作为一个新的提交引入到你当前分支上。当我们需要在本地合入其他分支的提交时，如果我们不想对整个分支进行合并，而是只想将某一次提交合入到本地当前分支上，那么就要使用 <code>git cherry-pick</code> 了。</p> <p>如下场景，以下有三条分支，feature/cherry-pick1 和 feature/cherry-pick2 都是基于 master 检出的两条功能性分支，对应的分支 log 记录如下</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66e205eb421841bfa476167e6fd7c581~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20210518221001432.png"></p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5743a18a0c24b3aa085db3d7a620742~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20210518221010458.png"></p> <p>master 分支的提交如下 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64fe055a5e764ff58e85923314096f9e~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20210518221051734.png"></p> <p>现在 master 只需要 feature/cherry-pick1 和 feature/cherry-pick2 有关 change 的修改，并不关心有关 fix 内容的修改。此时就可以用 cherry-pick 指令了。</p> <p>语法： <code>git cherry-pick [commit-hash]</code></p> <p>commit-hash 表示的是某次 commit 的 hash 值。现在，依次执行以下两条指令 <code>git cherry-pick e0bb7f3</code>、<code>git cherry-pick c9a3101</code>，过程中，如果出现冲突，解决冲突后 进行 <code>git add</code>，接着执行 <code>git cherry-pick --continue</code>，最后，master 上的提交如下</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38f9c71679824941abdf98b769b9a062~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20210518235707190.png"></p> <p>此时，master 分支上应用了需要的提交，就达到了我们想要的效果。如果需要多个 cherry-pick 需要同步到目标分支，可以简写为 <code>git cherry-pick &lt;first-commit-id&gt;...&lt;last-commit-id&gt;</code>，这是一个左开右闭的区间，也就时说 <code>first-commit-id</code> 提交带来的代码的改动不会被合并过去，如果需要合并过去，可以使用 <code>git cherry-pick &lt;first-commit-id&gt;^...&lt;last-commit-id&gt;</code>，它表示包含 <code>first-commit-id</code> 到 <code>last-commit-id</code> 在内的提交都会被合并过去。</p> <h4 id="使用-git-revert-回滚某次的提交"><a href="#使用-git-revert-回滚某次的提交" class="header-anchor">#</a> 使用 git revert 回滚某次的提交</h4> <p>想象这么一个场景，你的项目最近有 2 个版本要上线，这两个版本还伴随着之前遗留的 bug 的修复，一开始的时候，你将 bug 修复在了第一个版本的 release 分支上，突然在发版前一天，测试那边反馈，需要把第一个版本修复 bug 的内容改在第二个版本上，这个时候，第一个版本的集成分支的提交应该包括了第一个版本的功能内容，遗留 bug 修复的提交和其他同事提交的内容，想要通过 reset 的方式粗暴摘除之前的关于 bug 修复的 commit 肯定是不行的，同时，这种做法比较危险，此时，我们既不想破坏之前的提交记录，又想撤回我们遗留 bug 的 commit 记录应该怎么做呢？git revert 就派上了用场。</p> <blockquote><p><code>git revert</code> 撤销某次操作，此操作不会修改原本的提交记录，而是会新增一条提交记录来抵消某次操作。</p></blockquote> <p>语法： <code>git revert &lt;commit-id&gt;</code> 针对普通 commit</p> <p><code>git revert &lt;commit-id&gt; -m</code> 针对 merge 的 commit</p> <p>下面就用一个案例来理解一下这个命令，如下图所示，假设被红框框起来的地方是会引起 bug 的一次提交，在他的提交之后，又进行了 2 次提交，其中包含了其它同事的提交。</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f36331158e084072a033802bf4fa0478~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20210519142702752.png"></p> <p>此时想把引起提交的 bug 的干掉，执行 <code>git revert 1121932</code>，执行操作后，再打开查看日志，如下图所示，可以看到是新增了一条 commit 记录，这个 commit 的产生的 msg 是自动生成的，Revert 开头，后面跟撤回的 commit-msg 信息 之前的 commit 记录并没有消失，此时也达到了代码回退的效果</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9729e537218e4609b54df3e899fd332f~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20210519142824836.png"></p> <p>此外 git revert 也可以回滚多次的提交</p> <p>语法：<code>git revert [commit-id1] [commit-id2] ...</code> 注意这是一个前开后闭区间，即不包括 commit1 ，但包括 commit2 。</p> <p>回滚我们的提交有二种方式，一种是上文提到的<code>git revert</code>命令外，还可以使用 <code>git reset</code> 命令，那么它们两者有什么区别呢？</p> <p><code>git revert</code> 会新建一条 commit 信息，来撤回之前的修改。</p> <p><code>git reset</code> 会直接将提交记录退回到指定的 commit 上。</p> <p>对于个人的 feature 分支而言，可以使用 <code>git reset</code> 来回退历史记录，之后使用 <code>git push --force</code> 进行推送到远程，但是如果是在多人协作的集成分支上，不推荐直接使用 <code>git reset</code> 命令，而是使用更加安全的 <code>git revert</code> 命令进行撤回提交。这样，提交的历史记录不会被抹去，可以安全的进行撤回。</p> <h4 id="使用-git-stash-来暂存文件"><a href="#使用-git-stash-来暂存文件" class="header-anchor">#</a> 使用 git stash 来暂存文件</h4> <p>会有这么一个场景，现在你正在用你的 feature 分支上开发新功能。这时，生产环境上出现了一个 bug 需要紧急修复，但是你这部分代码还没开发完，不想提交，怎么办？这个时候可以用 <code>git stash</code> 命令先把工作区已经修改的文件暂存起来，然后切换到 hotfix 分支上进行 bug 的修复，修复完成后，切换回 feature 分支，从堆栈中恢复刚刚保存的内容。</p> <p>基本命令如下</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token function">git</span> stash //把本地的改动暂存起来
<span class="token function">git</span> stash save <span class="token string">&quot;message&quot;</span> 执行存储时，添加备注，方便查找。
<span class="token function">git</span> stash pop // 应用最近一次暂存的修改，并删除暂存的记录
<span class="token function">git</span> stash apply  // 应用某个存储,但不会把存储从存储列表中删除，默认使用第一个存储,即 stash@<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span>，如果要使用其他个，git stash apply stash@<span class="token punctuation">{</span><span class="token variable">$num</span><span class="token punctuation">}</span> 。
<span class="token function">git</span> stash list // 查看 stash 有哪些存储
<span class="token function">git</span> stash <span class="token function">clear</span> // 删除所有缓存的 stash
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>下面通过几幅图对 stash 的命令做进一步了解。</p> <p>此时，我正在开发一个新功能，修改了 1.js 文件里的内容</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd64645d30734e68a4e4349ea94ee064~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20210519175036869.png"></p> <p>还没开发完成，这个时候，我想切换到 hotfix 分支上修复 bug，得暂停下开发切换到 hotfix 分支，但是现在工作区还有内容，此时如果切换分支 Git 会报出下面的错误</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>error: Your <span class="token builtin class-name">local</span> changes to the following files would be overwritten by checkout:
        <span class="token number">1</span>.js
Please commit your changes or stash them before you switch branches.
Aborting
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>上面那句话的意思就是说工作区有文件修改，不能提交，需要先进行 commit 或者 stash 操作，执行 <code>git stash</code>，结果如下</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>Saved working directory and index state WIP on stash: 22e561c feat: <span class="token function">add</span> <span class="token number">1</span>.js
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>此时，我们的工作区已经干净了，可以切换到 hotfix 分支进行 bug 修复的工作，假设我们现在 bug 修复完成了，继续切回 feature 分支进行原本功能的开发，此时只需要执行 <code>git stash pop</code>，之前我们暂存的修改就会恢复到工作区，如下图所示。</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f4f3a3b24e042868829315b3209b760~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20210519185011012.png"></p> <p>当我们想要暂存文件，切换分支做某些事的时候，可以用 <code>git stash</code> 这种机制帮助开发。</p> <p>推荐在使用 stash 的相关命令时，每一次暂存的时候，不要直接使用 <code>git stash</code> 命令进行暂存下来，而是使用 <code>git stash save &quot;message...&quot;</code> 这种方式，给本次的提交做一个信息的记录。这样，想应用更改的时候，先通过 <code>git stash list</code> 查看一下所有的暂存列表。之后，推荐使用 <code>git stash apply stash@${num}</code> 的方式进行应用对应的 stash，这样不会清空已有的 stash 的列表项，并且能应用到当前的工作区，不需要这个暂存的话，再手动清除就可以了。</p> <h4 id="不同的工作区域撤销更改"><a href="#不同的工作区域撤销更改" class="header-anchor">#</a> 不同的工作区域撤销更改</h4> <p>开发中，我们经常需要回退代码的操作，在不同的工作区域中，回退代码的方式也是不相同的。如下图所示，假设现在要在 feature/revoke 分支上进行开发,</p> <p>首先通过 <code>git status</code> 查看下现在的状态。</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4ede8763be443868de951dc08721c1a~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20210520115802579.png"></p> <p>目前我们的工作区是很干净的，没有任何修改的操作，此时，修改一下代码再次查看状态，可以看到，1.js 这个文件被修改了。</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/371084f06fca40778b2f95900ebf19b6~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20210520115934693.png"></p> <p>现在我们想把 1.js 这个文件恢复到修改前的状态，即撤回工作区的修改，就可以使用 <code>git checkout -- &lt;filename&gt;</code> 的命令，如果要撤回多个文件的修改，文件之间使用空格隔开，如下图所示，我们撤回了 1.js 文件的修改，工作区也恢复干净了。</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02da2adecc3b43bd917294c203596d1e~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20210520120242475.png"></p> <p>如果说现在我们对文件进行了修改，并且已经提交到暂存区了，这部分文件我们不想要的话，那么就可以通过 <code>git reset &lt;filename&gt;</code> 的命令来对特定的文件进行撤销，<code>git reset</code> 会撤回所有存在暂存区的文件，如下图所示，查看前后的状态可知，文件最后成功撤回到工作区了。</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0d6b5e17ec341afb86e1e9732f2ded9~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20210520141538130.png"></p> <h4 id="配置-git-alias-提升工作效率"><a href="#配置-git-alias-提升工作效率" class="header-anchor">#</a> 配置 git alias 提升工作效率</h4> <p>一般我们在工作中，接到开发任务后，需要新创建一个分支进行开发 此时需要 用到 <code>git branch</code>、<code>git checkout</code>、 <code>git pull</code> 等命令，在我们一顿操作后，开发完成，到了提交代码的阶段，又要诸如此类 <code>git add</code> 、<code>git commit</code>、<code>git push</code> 等命令，虽然简单，但是输入起来也是不够简洁，作为一个程序员，开发程序就是为了提高我们的效率的，懒是人类进步的源泉，所以我们可以通过配置别名的方式，简化这些命令。</p> <p>它的基本用法是 <code>git config --global alias.&lt;简化的字符&gt; 原始命令</code></p> <p>如下面的例子：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>$ <span class="token function">git</span> config --global alias.co checkout
$ <span class="token function">git</span> config --global alias.ci commit
$ <span class="token function">git</span> config --global alias.br branch
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>这里将 co 表示 checkout，ci 表示 commit，br 表示 branch，以后提交就可以简写成</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9e4b6e415724ddbbeb85958b0e2ba05~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20210519152804390.png"></p> <p><code>--global</code> 是全局参数，也就是配置一次后，这些命令可以在这台电脑下的所有仓库都适用。这些命令其实是更新你全局的 .gitconfig 文件，该文件用来保存全局的 git 配置，<code>vim ~/.gitconfig</code>，执行这段命令后，显示如下，下图展示了刚才通过 <code>git config --global alias</code> 添加的 <code>alias</code>。</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6abbadf7e542451f808b79a644158bf6~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20210519153624712.png"></p> <p>除了上面那种直接通过命令的方式外，也可以通过修改这个文件的 <code>alias</code> 项来设置别名。</p> <p>这里分享一个我自己常用的别名设置，把以下配置替换到 .gitconfig 文件里的 <code>[alias]</code> 所属的区域，然后就可以愉快的使用了~</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token punctuation">[</span>alias<span class="token punctuation">]</span>
st <span class="token operator">=</span> status -sb
co <span class="token operator">=</span> checkout
br <span class="token operator">=</span> branch
mg <span class="token operator">=</span> merge
ci <span class="token operator">=</span> commit
ds <span class="token operator">=</span> <span class="token function">diff</span> --staged
dt <span class="token operator">=</span> difftool
mt <span class="token operator">=</span> mergetool
last <span class="token operator">=</span> log -1 HEAD
latest <span class="token operator">=</span> for-each-ref --sort<span class="token operator">=</span>-committerdate --format<span class="token operator">=</span><span class="token punctuation">\</span>&quot;%<span class="token punctuation">(</span>committername<span class="token punctuation">)</span>@%<span class="token punctuation">(</span>refname:short<span class="token punctuation">)</span> <span class="token punctuation">[</span>%<span class="token punctuation">(</span>committerdate:short<span class="token punctuation">)</span><span class="token punctuation">]</span> %<span class="token punctuation">(</span>contents<span class="token punctuation">)</span><span class="token punctuation">\</span>&quot;
<span class="token function">ls</span> <span class="token operator">=</span> log --pretty<span class="token operator">=</span>format:<span class="token punctuation">\</span>&quot;%C<span class="token punctuation">(</span>yellow<span class="token punctuation">)</span>%h %C<span class="token punctuation">(</span>blue<span class="token punctuation">)</span>%ad %C<span class="token punctuation">(</span>red<span class="token punctuation">)</span>%d %C<span class="token punctuation">(</span>reset<span class="token punctuation">)</span>%s %C<span class="token punctuation">(</span>green<span class="token punctuation">)</span><span class="token punctuation">[</span>%cn<span class="token punctuation">]</span><span class="token punctuation">\</span>&quot; --decorate --date<span class="token operator">=</span>short
hist <span class="token operator">=</span> log --pretty<span class="token operator">=</span>format:<span class="token punctuation">\</span>&quot;%C<span class="token punctuation">(</span>yellow<span class="token punctuation">)</span>%h %C<span class="token punctuation">(</span>red<span class="token punctuation">)</span>%d %C<span class="token punctuation">(</span>reset<span class="token punctuation">)</span>%s %C<span class="token punctuation">(</span>green<span class="token punctuation">)</span><span class="token punctuation">[</span>%an<span class="token punctuation">]</span> %C<span class="token punctuation">(</span>blue<span class="token punctuation">)</span>%ad<span class="token punctuation">\</span>&quot; --topo-order --graph --date<span class="token operator">=</span>short
<span class="token builtin class-name">type</span> <span class="token operator">=</span> cat-file -t
dump <span class="token operator">=</span> cat-file -p
lg <span class="token operator">=</span> log --color --graph --pretty<span class="token operator">=</span>format:<span class="token string">'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset'</span> --abbrev-commit
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>这样，我们每次想查看 Git 的历史记录,就不用输入那么一长串命令 直接使用 <code>git lg</code> ，下图是 axios 源码里的提交记录，使用封装后的 <code>git lg</code> 查看的效果图</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f5df1f881fa4c8fac9cc5868b35908a~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20210519162327693.png"></p> <p>分支之间的关系一眼就很明了，在哪个 commit 上进行的 merge 操作也很清晰，可以帮助我们很好的追溯历史的提交和解决问题。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/newblog/ready.html" class="prev">
        面试准备
      </a></span> <span class="next"><a href="/newblog/favorites.html">
        收藏夹
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/newblog/assets/js/app.dfcbd65b.js" defer></script><script src="/newblog/assets/js/2.6c36ac49.js" defer></script><script src="/newblog/assets/js/21.a514ea92.js" defer></script>
  </body>
</html>
