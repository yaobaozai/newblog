(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{369:function(e,a,s){"use strict";s.r(a);var l=s(44),v=Object(l.a)({},(function(){var e=this,a=e.$createElement,s=e._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"md"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#md"}},[e._v("#")]),e._v(" md")]),e._v(" "),s("p",[e._v("预计分享\n1.cmd与es module\n2.什么是esbuild\n3.vue3 ts项目搭建\n4.组内架构回顾\n待做事项\n1.填坑\n7月份想填完的坑 前端架构师课程")]),e._v(" "),s("p",[e._v("今天学习neirong")]),e._v(" "),s("h3",{attrs:{id:"yargs"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#yargs"}},[e._v("#")]),e._v(" yargs")]),e._v(" "),s("ul",[s("li",[e._v("脚手架构成\n"),s("ul",[s("li",[e._v("bin：package.json中配置bin属性，npm link 本地安装")]),e._v(" "),s("li",[e._v("command：命令")]),e._v(" "),s("li",[e._v("options：参数（boolean/string/number）")]),e._v(" "),s("li",[e._v("文件顶部增加 "),s("code",[e._v("#!/usr/bin/env node")])])])]),e._v(" "),s("li",[e._v("脚手架初始化流程\n"),s("ul",[s("li",[e._v("构造函数：Yargs()")]),e._v(" "),s("li",[e._v("常用方法：\n"),s("ul",[s("li",[e._v("Yargs.options")]),e._v(" "),s("li",[e._v("Yargs.option")]),e._v(" "),s("li",[e._v("Yargs.group")]),e._v(" "),s("li",[e._v("Yargs.demandCommand")]),e._v(" "),s("li",[e._v("Yargs.recommendCommands")]),e._v(" "),s("li",[e._v("Yargs.strict")]),e._v(" "),s("li",[e._v("Yargs.fail")]),e._v(" "),s("li",[e._v("Yargs.alias")]),e._v(" "),s("li",[e._v("Yargs.wrap")]),e._v(" "),s("li",[e._v("Yargs.epilogue")])])])])]),e._v(" "),s("li",[e._v("脚手架参数解析方法\n"),s("ul",[s("li",[e._v("hideBin(process.argv) / Yargs.argv")]),e._v(" "),s("li",[e._v("Yargs.parse(argv, options)")])])]),e._v(" "),s("li",[e._v("命令注册方法\n"),s("ul",[s("li",[e._v("Yargs.command(command, describe, builder, handler)")]),e._v(" "),s("li",[e._v("Yargs.command({ command, describe, builder, handler })")])])])]),e._v(" "),s("h3",{attrs:{id:"lerna"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#lerna"}},[e._v("#")]),e._v(" Lerna")]),e._v(" "),s("ul",[s("li",[e._v("Lerna 是基于 git+npm 的多package项目管理工具")]),e._v(" "),s("li",[e._v("实现原理\n"),s("ul",[s("li",[e._v("通过 import-local 优先调用本地 lerna 命令")]),e._v(" "),s("li",[e._v("通过 Yargs 生成脚手架，先注册全局属性，再注册命令，最后通过 parse 方法解析参数")]),e._v(" "),s("li",[e._v("lerna 命令注册时需要传入 builder 和 handler 两个方法，builder 方法用于注册命令专属的 options，handler 用来处理命令的业务逻辑")]),e._v(" "),s("li",[e._v("lerna 通过配置 npm 本地依赖的方式来进行本地开发，具体写法是在 package.json 的依赖中写入："),s("code",[e._v("file:your-local-module-path")]),e._v(" ，在 lerna publish 时会自动将该路径替换")])])])]),e._v(" "),s("h3",{attrs:{id:"node-js-模块路径解析流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#node-js-模块路径解析流程"}},[e._v("#")]),e._v(" Node.js 模块路径解析流程")]),e._v(" "),s("ul",[s("li",[s("p",[e._v("Node.js 项目模块路径解析是通过 "),s("code",[e._v("require.resolve")]),e._v(" 方法来实现的")])]),e._v(" "),s("li",[s("p",[s("code",[e._v("require.resolve")]),e._v(" 就是通过 "),s("code",[e._v("Module._resolveFileName")]),e._v(" 方法实现的")])]),e._v(" "),s("li",[s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("require.resolve\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("p",[e._v("实现原理：")]),e._v(" "),s("ul",[s("li",[s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("Module._resolveFileName\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("p",[e._v("方法核心流程有 3 点：")]),e._v(" "),s("ul",[s("li",[e._v("判断是否为内置模块")]),e._v(" "),s("li",[e._v("通过 "),s("code",[e._v("Module._resolveLookupPaths")]),e._v(" 方法生成 node_modules 可能存在的路径")]),e._v(" "),s("li",[e._v("通过 "),s("code",[e._v("Module._findPath")]),e._v(" 查询模块的真实路径")])])]),e._v(" "),s("li",[s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("Module._findPath\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("p",[e._v("核心流程有 4 点：")]),e._v(" "),s("ul",[s("li",[e._v("查询缓存（将 request 和 paths 通过 "),s("code",[e._v("\\x00")]),e._v(" 合并成 cacheKey）")]),e._v(" "),s("li",[e._v("遍历 paths，将 path 与 request 组成文件路径 basePath")]),e._v(" "),s("li",[e._v("如果 basePath 存在则调用 "),s("code",[e._v("fs.realPathSync")]),e._v(" 获取文件真实路径")]),e._v(" "),s("li",[e._v("将文件真实路径缓存到 "),s("code",[e._v("Module._pathCache")]),e._v("（key 就是前面生成的 cacheKey）")])])]),e._v(" "),s("li",[s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("fs.realPathSync\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("p",[e._v("核心流程有 3 点：")]),e._v(" "),s("ul",[s("li",[s("p",[e._v("查询缓存（缓存的 key 为 p，即 "),s("code",[e._v("Module._findPath")]),e._v(" 中生成的文件路径）")])]),e._v(" "),s("li",[s("p",[e._v("从左往右遍历路径字符串，查询到")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("/\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("p",[e._v("时，拆分路径，判断该路径是否为软链接，如果是软链接则查询真实链接，并生成新路径 p，然后继续往后遍历，这里有 1 个细节需要特别注意：")]),e._v(" "),s("ul",[s("li",[e._v("遍历过程中生成的子路径 base 会缓存在 knownHard 和 cache 中，避免重复查询")])])]),e._v(" "),s("li",[s("p",[e._v("遍历完成得到模块对应的真实路径，此时会将原始路径 original 作为 key，真实路径作为 value，保存到缓存中")])])])])])]),e._v(" "),s("li",[s("p",[s("code",[e._v("require.resolve.paths")]),e._v(" 等价于 "),s("code",[e._v("Module._resolveLookupPaths")]),e._v("，该方法用于获取所有 node_modules 可能存在的路径")])]),e._v(" "),s("li",[s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("require.resolve.paths\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("p",[e._v("实现原理：")]),e._v(" "),s("ul",[s("li",[e._v("如果路径为 "),s("code",[e._v("/")]),e._v("（根目录），直接返回 "),s("code",[e._v("['/node_modules']")])]),e._v(" "),s("li",[e._v("否则，将路径字符串从后往前遍历，查询到 "),s("code",[e._v("/")]),e._v(" 时，拆分路径，在后面加上 node_modules，并传入一个 paths 数组，直至查询不到 "),s("code",[e._v("/")]),e._v(" 后返回 paths 数组")])])])])])}),[],!1,null,null,null);a.default=v.exports}}]);